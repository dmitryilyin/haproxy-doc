\chapter{Using ACLs and pattern extraction}
\label{chap:using_acl}

The use of Access Control Lists (ACL) provides a flexible solution to perform
content switching and generally to take decisions based on content extracted
from the request, the response or any environmental status. The principle is
simple:

\begin{itemize}
\item[-] define test criteria with sets of values
\item[-] perform actions only if a set of tests is valid
\end{itemize}

The actions generally consist in blocking the request, or selecting a backend.

In order to define a test, the "acl" keyword is used. The syntax is:

\begin{verbatim}
   acl <aclname> <criterion> [flags] [operator] <value> ...
\end{verbatim}

\index{acl}
This creates a new ACL <aclname> or completes an existing one with new tests.
Those tests apply to the portion of request/response specified in <criterion>
and may be adjusted with optional flags [flags]. Some criteria also support
an operator which may be specified before the set of values. The values are
of the type supported by the criterion, and are separated by spaces.

ACL names must be formed from upper and lower case letters, digits, '\verb|-|' (dash),
'\verb|_|' (underscore) , '\verb|.|' (dot) and '\verb|:|' (colon). ACL names are case-sensitive,
which means that "my\_acl" and "My\_Acl" are two different ACLs.

There is no enforced limit to the number of ACLs. The unused ones do not affect
performance, they just consume a small amount of memory.

The following ACL flags are currently supported:

\begin{description}
\item[-i] ignore case during matching of all subsequent patterns.
\item[-f] load patterns from a file.
\item[{-}{-}] force end of flags. Useful when a string looks like one of the flags.
\end{description}

The "-f" flag is special as it loads all of the lines it finds in the file
specified in argument and loads all of them before continuing. It is even
possible to pass multiple "-f" arguments if the patterns are to be loaded from
multiple files. Empty lines as well as lines beginning with a sharp ('\#') will
be ignored. All leading spaces and tabs will be stripped. If it is absolutely
needed to insert a valid pattern beginning with a sharp, just prefix it with a
space so that it is not taken for a comment. Depending on the data type and
match method, haproxy may load the lines into a binary tree, allowing very fast
lookups. This is true for IPv4 and exact string matching. In this case,
duplicates will automatically be removed. Also, note that the "-i" flag applies
to subsequent entries and not to entries loaded from files preceeding it. For
instance:

\begin{verbatim}
    acl valid-ua hdr(user-agent) -f exact-ua.lst -i -f generic-ua.lst  test
\end{verbatim}

In this example, each line of "exact-ua.lst" will be exactly matched against
the "user-agent" header of the request. Then each line of "generic-ua" will be
case-insensitively matched. Then the word "test" will be insensitively matched
too.

Note that right now it is difficult for the ACL parsers to report errors, so if
a file is unreadable or unparsable, the most you'll get is a parse error in the
ACL. Thus, file-based ACLs should only be produced by reliable processes.

Supported types of values are:
\begin{itemize}
\item[-] integers or integer ranges
\item[-] strings
\item[-] regular expressions
\item[-] IP addresses and networks
\end{itemize}

\section{Matching integers}

\index{Matching integers}
Matching integers is special in that ranges and operators are permitted. Note
that integer matching only applies to positive values. A range is a value
expressed with a lower and an upper bound separated with a colon, both of which
may be omitted.

For instance, "1024:65535" is a valid range to represent a range of
unprivileged ports, and "1024:" would also work. "0:1023" is a valid
representation of privileged ports, and ":1023" would also work.

As a special case, some ACL functions support decimal numbers which are in fact
two integers separated by a dot. This is used with some version checks for
instance. All integer properties apply to those decimal numbers, including
ranges and operators.

For an easier usage, comparison operators are also supported. Note that using
operators with ranges does not make much sense and is strongly discouraged.
Similarly, it does not make much sense to perform order comparisons with a set
of values.

Available operators for integer matching are:

\begin{description}
\item[eq] true if the tested value equals at least one value
\item[ge] true if the tested value is greater than or equal to at least one value
\item[gt] true if the tested value is greater than at least one value
\item[le] true if the tested value is less than or equal to at least one value
\item[lt] true if the tested value is less than at least one value
\end{description}

For instance, the following ACL matches any negative Content-Length header:

\begin{verbatim}
  acl negative-length hdr_val(content-length) lt 0
\end{verbatim}

This one matches SSL versions between 3.0 and 3.1 (inclusive):

\begin{verbatim}
  acl sslv3 req_ssl_ver 3:3.1
\end{verbatim}

\section{Matching strings}

\index{Matching strings}
String matching applies to verbatim strings as they are passed, with the
exception of the backslash ('\verb|\|') which makes it possible to escape some
characters such as the space. If the "-i" flag is passed before the first
string, then the matching will be performed ignoring the case. In order
to match the string "-i", either set it second, or pass the "\verb|--|" flag
before the first string. Same applies of course to match the string "\verb|--|".

\section{Matching regular expressions (regexes)}

\index{Matching regular expressions}
Just like with string matching, regex matching applies to verbatim strings as
they are passed, with the exception of the backslash ('\verb|\|') which makes it
possible to escape some characters such as the space. If the "-i" flag is
passed before the first regex, then the matching will be performed ignoring
the case. In order to match the string "-i", either set it second, or pass
the "\verb|--|" flag before the first string. Same principle applies of course to
match the string "\verb|--|".

\section{Matching IPv4 and IPv6 addresses}

\index{Matching IPv4 and IPv6 addresses}
IPv4 addresses values can be specified either as plain addresses or with a
netmask appended, in which case the IPv4 address matches whenever it is
within the network. Plain addresses may also be replaced with a resolvable
host name, but this practice is generally discouraged as it makes it more
difficult to read and debug configurations. If hostnames are used, you should
at least ensure that they are present in \texttt{/etc/hosts} so that the configuration
does not depend on any random DNS match at the moment the configuration is
parsed.

IPv6 may be entered in their usual form, with or without a netmask appended.
Only bit counts are accepted for IPv6 netmasks. In order to avoid any risk of
trouble with randomly resolved IP addresses, host names are never allowed in
IPv6 patterns.

HAProxy is also able to match IPv4 addresses with IPv6 addresses in the
following situations:
\begin{itemize}
\item[-] tested address is IPv4, pattern address is IPv4, the match applies
    in IPv4 using the supplied mask if any.
\item[-] tested address is IPv6, pattern address is IPv6, the match applies
    in IPv6 using the supplied mask if any.
\item[-] tested address is IPv6, pattern address is IPv4, the match applies in IPv4
    using the pattern's mask if the IPv6 address matches with 2002:IPV4::,
    ::IPV4 or ::ffff:IPV4, otherwise it fails.
\item[-] tested address is IPv4, pattern address is IPv6, the IPv4 address is first
    converted to IPv6 by prefixing ::ffff: in front of it, then the match is
    applied in IPv6 using the supplied IPv6 mask.
\end{itemize}

\section{Available matching criteria}

\subsection{Matching at Layer 4 and below}

\index{Matching at Layer 4 and below}
A first set of criteria applies to information which does not require any
analysis of the request or response contents. Those generally include TCP/IP
addresses and ports, as well as internal values independent on the stream.

\subsubsection[always\_false]{always\_false}
\index{always\_false}
  This one never matches. All values and flags are ignored. It may be used as
  a temporary replacement for another one when adjusting configurations.

\subsubsection[always\_true]{always\_true}
\index{always\_true}
  This one always matches. All values and flags are ignored. It may be used as
  a temporary replacement for another one when adjusting configurations.

\subsubsection[avg\_queue]{avg\_queue <integer>}
\subsubsection*{avg\_queue(<backend>) <integer>}
\index{avg\_queue}
  Returns the total number of queued connections of the designated backend
  divided by the number of active servers. This is very similar to "queue"
  except that the size of the farm is considered, in order to give a more
  accurate measurement of the time it may take for a new connection to be
  processed. The main usage is to return a sorry page to new users when it
  becomes certain they will get a degraded service. Note that in the event
  there would not be any active server anymore, we would consider twice the
  number of queued connections as the measured value. This is a fair estimate,
  as we expect one server to get back soon anyway, but we still prefer to send
  new traffic to another backend if in better shape. See also the "queue",
  "be\_conn", and "be\_sess\_rate" criteria.

\subsubsection[be\_conn]{be\_conn <integer>}
\subsubsection*{be\_conn(<backend>) <integer>}
\index{be\_conn}
  Applies to the number of currently established connections on the backend,
  possibly including the connection being evaluated. If no backend name is
  specified, the current one is used. But it is also possible to check another
  backend. It can be used to use a specific farm when the nominal one is full.
  See also the "fe\_conn", "queue" and "be\_sess\_rate" criteria.

\subsubsection[be\_id]{be\_id <integer>}
\index{be\_id}
  Applies to the backend's id. Can be used in frontends to check from which
  backend it was called.

\subsubsection[be\_sess\_rate]{be\_sess\_rate <integer>}
\subsubsection*{be\_sess\_rate(<backend>) <integer>}
\index{be\_sess\_rate}
  Returns true when the sessions creation rate on the backend matches the
  specified values or ranges, in number of new sessions per second. This is
  used to switch to an alternate backend when an expensive or fragile one
  reaches too high a session rate, or to limit abuse of service (eg. prevent
  sucking of an online dictionary).

  Example:
  \begin{verbatim}
        # Redirect to an error page if the dictionary is requested too often
        backend dynamic
            mode http
            acl being_scanned be_sess_rate gt 100
            redirect location /denied.html if being_scanned
  \end{verbatim}

\subsubsection[connslots]{connslots <integer>}
\subsubsection*{connslots(<backend>) <integer>}
\index{connslots}
  The basic idea here is to be able to measure the number of connection "slots"
  still available (connection + queue), so that anything beyond that (intended
  usage; see "use\_backend" keyword) can be redirected to a different backend.

  'connslots' = number of available server connection slots, + number of
  available server queue slots.

  Note that while "fe\_conn" may be used, "connslots" comes in especially
  useful when you have a case of traffic going to one single ip, splitting into
  multiple backends (perhaps using acls to do name-based load balancing) and
  you want to be able to differentiate between different backends, and their
  available "connslots".  Also, whereas "nbsrv" only measures servers that are
  actually *down*, this acl is more fine-grained and looks into the number of
  available connection slots as well. See also "queue" and "avg\_queue".

  \emph{Other caveats and notes:} at this point in time, the code does not take care
  of dynamic connections. Also, if any of the server maxconn, or maxqueue is 0,
  then this acl clearly does not make sense, in which case the value returned
  will be -1.

\subsubsection[dst]{dst <ip\_address>}
\index{dst}
  Applies to the local IPv4 or IPv6 address the client connected to. It can be
  used to switch to a different backend for some alternative addresses.

\subsubsection[dst\_conn]{dst\_conn <integer>}
\index{dst\_conn}
  Applies to the number of currently established connections on the same socket
  including the one being evaluated. It can be used to either return a sorry
  page before hard-blocking, or to use a specific backend to drain new requests
  when the socket is considered saturated. This offers the ability to assign
  different limits to different listening ports or addresses. See also the
  "fe\_conn" and "be\_conn" criteria.

\subsubsection[dst\_port]{dst\_port <integer>}
\index{dst\_port}
  Applies to the local port the client connected to. It can be used to switch
  to a different backend for some alternative ports.

\subsubsection[fe_conn]{fe\_conn <integer>}
\subsubsection*{fe\_conn(<frontend>) <integer>}
\index{fe\_conn}
  Applies to the number of currently established connections on the frontend,
  possibly including the connection being evaluated. If no frontend name is
  specified, the current one is used. But it is also possible to check another
  frontend. It can be used to either return a sorry page before hard-blocking,
  or to use a specific backend to drain new requests when the farm is
  considered saturated. See also the "dst\_conn", "be\_conn" and "fe\_sess\_rate"
  criteria.

\subsubsection[fe\_id]{fe\_id <integer>}
\index{fe\_id}
  Applies to the frontend's id. Can be used in backends to check from which
  frontend it was called.

\subsubsection[fe\_sess\_rate]{fe\_sess\_rate <integer>}
\subsubsection*{fe\_sess\_rate(<frontend>) <integer>}
\index{fe\_sess\_rate}
  Returns true when the session creation rate on the current or the named
  frontend matches the specified values or ranges, expressed in new sessions
  per second. This is used to limit the connection rate to acceptable ranges in
  order to prevent abuse of service at the earliest moment. This can be
  combined with layer 4 ACLs in order to force the clients to wait a bit for
  the rate to go down below the limit.

  Example:
  \begin{verbatim}
        # This frontend limits incoming mails to 10/s with a max of 100
        # concurrent connections. We accept any connection below 10/s, and
        # force excess clients to wait for 100 ms. Since clients are limited to
        # 100 max, there cannot be more than 10 incoming mails per second.
        frontend mail
            bind :25
            mode tcp
            maxconn 100
            acl too_fast fe_sess_rate ge 10
            tcp-request inspect-delay 100ms
            tcp-request content accept if ! too_fast
            tcp-request content accept if WAIT_END
  \end{verbatim}

\subsubsection[nbsrv]{nbsrv <integer>}
\subsubsection*{nbsrv(<backend>) <integer>}
\index{nbsrv}
  Returns true when the number of usable servers of either the current backend
  or the named backend matches the values or ranges specified. This is used to
  switch to an alternate backend when the number of servers is too low to
  to handle some load. It is useful to report a failure when combined with
  "monitor fail".

\subsubsection[queue]{queue <integer>}
\subsubsection*{queue(<backend>) <integer>}
\index{queue}
  Returns the total number of queued connections of the designated backend,
  including all the connections in server queues. If no backend name is
  specified, the current one is used, but it is also possible to check another
  one. This can be used to take actions when queuing goes above a known level,
  generally indicating a surge of traffic or a massive slowdown on the servers.
  One possible action could be to reject new users but still accept old ones.
  See also the "avg\_queue", "be\_conn", and "be\_sess\_rate" criteria.

\subsubsection[sc1\_bytes\_in\_rate]{sc1\_bytes\_in\_rate}
\subsubsection[sc2\_bytes\_in\_rate]{sc2\_bytes\_in\_rate}
\index{sc1\_bytes\_in\_rate}
\index{sc2\_bytes\_in\_rate}
  Returns the average client-to-server bytes rate from the currently tracked
  counters, measured in amount of bytes over the period configured in the
  table. See also src\_bytes\_in\_rate.

\subsubsection[sc1\_bytes\_out\_rate]{sc1\_bytes\_out\_rate}
\subsubsection[sc2\_bytes\_out\_rate]{sc2\_bytes\_out\_rate}
\index{sc1\_bytes\_out\_rate}
\index{sc2\_bytes\_out\_rate}
  Returns the average server-to-client bytes rate from the currently tracked
  counters, measured in amount of bytes over the period configured in the
  table. See also src\_bytes\_out\_rate.

\subsubsection[sc1\_clr\_gpc0]{sc1\_clr\_gpc0}
\subsubsection[sc2\_clr\_gpc0]{sc2\_clr\_gpc0}
\index{sc1\_clr\_gpc0}
\index{sc2\_clr\_gpc0}
  Clears the first General Purpose Counter associated to the currently tracked
  counters, and returns its previous value. Before the first invocation, the
  stored value is zero, so first invocation will always return zero. The test
  can also be used alone and always returns true. This is typically used as a
  second ACL in an expression in order to mark a connection when a first ACL
  was verified:
  
  \begin{verbatim}
        # block if 5 consecutive requests continue to come faster than 10 sess
        # per second, and reset the counter as soon as the traffic slows down.
        acl abuse sc1_http_req_rate gt 10
        acl kill  sc1_inc_gpc0 gt 5
        acl save  sc1_clr_gpc0
        tcp-request connection accept if !abuse save
        tcp-request connection reject if abuse kill
  \end{verbatim}

\subsubsection[sc1\_conn\_cnt]{sc1\_conn\_cnt}
\subsubsection[sc2\_conn\_cnt]{sc2\_conn\_cnt}
\index{sc1\_conn\_cnt}
\index{sc2\_conn\_cnt}
  Returns the cumulated number of incoming connections from currently tracked
  counters. See also src\_conn\_cnt.

\subsubsection[sc1\_conn\_cur]{sc1\_conn\_cur}
\subsubsection[sc2\_conn\_cur]{sc2\_conn\_cur}
\index{sc1\_conn\_cur}
\index{sc2\_conn\_cur}
  Returns the current amount of concurrent connections tracking the same
  tracked counters. This number is automatically incremented when tracking
  begins and decremented when tracking stops. See also src\_conn\_cur.

\subsubsection[sc1\_conn\_rate]{sc1\_conn\_rate}
\subsubsection[sc2\_conn\_rate]{sc2\_conn\_rate}
\index{sc1\_conn\_rate}
\index{sc2\_conn\_rate}
  Returns the average connection rate from the currently tracked counters,
  measured in amount of connections over the period configured in the table.
  See also src\_conn\_rate.

\subsubsection[sc1\_get\_gpc0]{sc1\_get\_gpc0}
\subsubsection[sc2\_get\_gpc0]{sc2\_get\_gpc0}
\index{sc1\_get\_gpc0}
\index{sc2\_get\_gpc0}
  Returns the value of the first General Purpose Counter associated to the
  currently tracked counters. See also src\_get\_gpc0 and sc1/sc2\_inc\_gpc0.

\subsubsection[sc1\_http\_err\_cnt]{sc1\_http\_err\_cnt}
\subsubsection[sc2\_http\_err\_cnt]{sc2\_http\_err\_cnt}
\index{sc1\_http\_err\_cnt}
\index{sc2\_http\_err\_cnt}
  Returns the cumulated number of HTTP errors from the currently tracked
  counters. This includes the both request errors and 4xx error responses.
  See also src\_http\_err\_cnt.

\subsubsection[sc1\_http\_err\_rate]{sc1\_http\_err\_rate}
\subsubsection[sc2\_http\_err\_rate]{sc2\_http\_err\_rate}
\index{sc1\_http\_err\_rate}
\index{sc2\_http\_err\_rate}
  Returns the average rate of HTTP errors from the currently tracked counters,
  measured in amount of errors over the period configured in the table. This
  includes the both request errors and 4xx error responses. See also
  src\_http\_err\_rate.

\subsubsection[sc1\_http\_req\_cnt]{sc1\_http\_req\_cnt}
\subsubsection[sc2\_http\_req\_cnt]{sc2\_http\_req\_cnt}
\index{sc1\_http\_req\_cnt}
\index{sc2\_http\_req\_cnt}
  Returns the cumulated number of HTTP requests from the currently tracked
  counters. This includes every started request, valid or not. See also
  src\_http\_req\_cnt.

\subsubsection[sc1\_http\_req\_rate]{sc1\_http\_req\_rate}
\subsubsection[sc2\_http\_req\_rate]{sc2\_http\_req\_rate}
\index{sc1\_http\_req\_rate}
\index{sc2\_http\_req\_rate}
  Returns the average rate of HTTP requests from the currently tracked
  counters, measured in amount of requests over the period configured in
  the table. This includes every started request, valid or not. See also
  src\_http\_req\_rate.

\subsubsection[sc1\_inc\_gpc0]{sc1\_inc\_gpc0}
\subsubsection[sc2\_inc\_gpc0]{sc2\_inc\_gpc0}
\index{sc1\_inc\_gpc0}
\index{sc2\_inc\_gpc0}
  Increments the first General Purpose Counter associated to the currently
  tracked counters, and returns its value. Before the first invocation, the
  stored value is zero, so first invocation will increase it to 1 and will
  return 1. The test can also be used alone and always returns true. This is
  typically used as a second ACL in an expression in order to mark a connection
  when a first ACL was verified:
  \begin{verbatim}
        acl abuse sc1_http_req_rate gt 10
        acl kill  sc1_inc_gpc0
        tcp-request connection reject if abuse kill
  \end{verbatim}

\subsubsection[sc1\_kbytes\_in]{sc1\_kbytes\_in}
\subsubsection[sc2\_kbytes\_in]{sc2\_kbytes\_in}
\index{sc1\_kbytes\_in}
\index{sc2\_kbytes\_in}
  Returns the amount of client-to-server data from the currently tracked
  counters, measured in kilobytes over the period configured in the table. The
  test is currently performed on 32-bit integers, which limits values to 4
  terabytes. See also src\_kbytes\_in.

\subsubsection[sc1\_kbytes\_out]{sc1\_kbytes\_out}
\subsubsection[sc2\_kbytes\_out]{sc2\_kbytes\_out}
\index{sc1\_kbytes\_out}
\index{sc2\_kbytes\_out}
  Returns the amount of server-to-client data from the currently tracked
  counters, measured in kilobytes over the period configured in the table. The
  test is currently performed on 32-bit integers, which limits values to 4
  terabytes. See also src\_kbytes\_out.

\subsubsection[sc1\_sess\_cnt]{sc1\_sess\_cnt}
\subsubsection[sc2\_sess\_cnt]{sc2\_sess\_cnt}
\index{sc1\_sess\_cnt}
\index{sc2\_sess\_cnt}
  Returns the cumulated number of incoming connections that were transformed
  into sessions, which means that they were accepted by a "tcp-request
  connection" rule, from the currently tracked counters. A backend may count
  more sessions than connections because each connection could result in many
  backend sessions if some HTTP keep-alive is performend over the connection
  with the client. See also src\_sess\_cnt.

\subsubsection[sc1\_sess\_rate]{sc1\_sess\_rate}
\subsubsection[sc2\_sess\_rate]{sc2\_sess\_rate}
\index{sc1\_sess\_rate}
\index{sc2\_sess\_rate}
  Returns the average session rate from the currently tracked counters,
  measured in amount of sessions over the period configured in the table. A
  session is a connection that got past the early "tcp-request connection"
  rules. A backend may count more sessions than connections because each
  connection could result in many backend sessions if some HTTP keep-alive is
  performed over the connection with the client. See also src\_sess\_rate.

\subsubsection[so\_id]{so\_id <integer>}
\index{so\_id}
  Applies to the socket's id. Useful in frontends with many bind keywords.

\subsubsection[src]{src <ip\_address>}
\index{src}
  Applies to the client's IPv4 or IPv6 address. It is usually used to limit
  access to certain resources such as statistics. Note that it is the TCP-level
  source address which is used, and not the address of a client behind a proxy.

\subsubsection[src\_bytes\_in\_rate]{src\_bytes\_in\_rate <integer>}
\subsubsection*{src\_bytes\_in\_rate(<table>) <integer>}
\index{src\_bytes\_in\_rate}
  Returns the average bytes rate from the connection's source IPv4 address in
  the current proxy's stick-table or in the designated stick-table, measured in
  amount of bytes over the period configured in the table. If the address is
  not found, zero is returned. See also sc1/sc2\_bytes\_in\_rate.

\subsubsection[src\_bytes\_out\_rate]{src\_bytes\_out\_rate <integer>}
\subsubsection*{src\_bytes\_out\_rate(<table>) <integer>}
\index{src\_bytes\_out\_rate}
  Returns the average bytes rate to the connection's source IPv4 address in the
  current proxy's stick-table or in the designated stick-table, measured in
  amount of bytes over the period configured in the table. If the address is
  not found, zero is returned. See also sc1/sc2\_bytes\_out\_rate.

\subsubsection[src\_clr\_gpc0]{src\_clr\_gpc0 <integer>}
\subsubsection*{src\_clr\_gpc0(<table>) <integer>}
\index{src\_clr\_gpc0}
  Clears the first General Purpose Counter associated to the connection's
  source IPv4 address in the current proxy's stick-table or in the designated
  stick-table, and returns its previous value. If the address is not found, an
  entry is created and 0 is returned. The test can also be used alone and
  always returns true. This is typically used as a second ACL in an expression
  in order to mark a connection when a first ACL was verified:

\begin{verbatim}
        # block if 5 consecutive requests continue to come faster than 10 sess
        # per second, and reset the counter as soon as the traffic slows down.
        acl abuse src_http_req_rate gt 10
        acl kill  src_inc_gpc0 gt 5
        acl save  src_clr_gpc0
        tcp-request connection accept if !abuse save
        tcp-request connection reject if abuse kill
\end{verbatim}

\subsubsection[src\_conn\_cnt]{src\_conn\_cnt <integer>}
\subsubsection*{src\_conn\_cnt(<table>) <integer>}
\index{src\_conn\_cnt}
  Returns the cumulated number of connections initiated from the current
  connection's source IPv4 address in the current proxy's stick-table or in
  the designated stick-table. If the address is not found, zero is returned.
  See also sc1/sc2\_conn\_cnt.

\subsubsection[src\_conn\_cur]{src\_conn\_cur <integer>}
\subsubsection*{src\_conn\_cur(<table>) <integer>}

\index{src\_conn\_cur}

  Returns the current amount of concurrent connections initiated from the
  current connection's source IPv4 address in the current proxy's stick-table
  or in the designated stick-table. If the address is not found, zero is
  returned. See also sc1/sc2\_conn\_cur.

\subsubsection[src\_conn\_rate]{src\_conn\_rate <integer>}
\subsubsection*{src\_conn\_rate(<table>) <integer>}
\index{src\_conn\_rate}
  Returns the average connection rate from the connection's source IPv4 address
  in the current proxy's stick-table or in the designated stick-table, measured
  in amount of connections over the period configured in the table. If the
  address is not found, zero is returned. See also sc1/sc2\_conn\_rate.

\subsubsection[src\_get\_gpc0]{src\_get\_gpc0 <integer>}
\subsubsection*{src\_get\_gpc0(<table>) <integer>}
\index{src\_get\_gpc0}
  Returns the value of the first General Purpose Counter associated to the
  connection's source IPv4 address in the current proxy's stick-table or in
  the designated stick-table. If the address is not found, zero is returned.
  See also sc1/sc2\_get\_gpc0 and src\_inc\_gpc0.

\subsubsection[src\_http\_err\_cnt]{src\_http\_err\_cnt <integer>}
\subsubsection*{src\_http\_err\_cnt(<table>) <integer>}
\index{src\_http\_err\_cnt}
  Returns the cumulated number of HTTP errors from the current connection's
  source IPv4 address in the current proxy's stick-table or in the designated
  stick-table. This includes the both request errors and 4xx error responses.
  If the address is not found, zero is returned. See also sc1/sc2\_http\_err\_cnt.

\subsubsection[src\_http\_err\_rate]{src\_http\_err\_rate <integer>}
\subsubsection{src\_http\_err\_rate(<table>) <integer>}
\index{src\_http\_err\_rate}
  Returns the average rate of HTTP errors from the current connection's source
  IPv4 address in the current proxy's stick-table or in the designated stick-
  table, measured in amount of errors over the period configured in the table.
  This includes the both request errors and 4xx error responses. If the address
  is not found, zero is returned. See also sc1/sc2\_http\_err\_rate.

\subsubsection[src\_http\_req\_cnt]{src\_http\_req\_cnt <integer>}
\subsubsection*{src\_http\_req\_cnt(<table>) <integer>}
\index{src\_http\_req\_cnt}
  Returns the cumulated number of HTTP requests from the current connection's
  source IPv4 address in the current proxy's stick-table or in the designated
  stick-table. This includes every started request, valid or not. If the
  address is not found, zero is returned. See also sc1/sc2\_http\_req\_cnt.

\subsubsection[src\_http\_req\_rate]{src\_http\_req\_rate <integer>}
\subsubsection*{src\_http\_req\_rate(<table>) <integer>}
  Returns the average rate of HTTP requests from the current connection's
  source IPv4 address in the current proxy's stick-table or in the designated
  stick-table, measured in amount of requests over the period configured in the
  table. This includes every started request, valid or not. If the address is
  not found, zero is returned. See also sc1/sc2\_http\_req\_rate.

\subsubsection[src\_inc\_gpc0]{src\_inc\_gpc0 <integer>}
\subsubsection{src\_inc\_gpc0(<table>) <integer>}
\index{src\_inc\_gpc0}
  Increments the first General Purpose Counter associated to the connection's
  source IPv4 address in the current proxy's stick-table or in the designated
  stick-table, and returns its value. If the address is not found, an entry is
  created and 1 is returned. The test can also be used alone and always returns
  true. This is typically used as a second ACL in an expression in order to
  mark a connection when a first ACL was verified:
  \begin{verbatim}
        acl abuse src_http_req_rate gt 10
        acl kill  src_inc_gpc0
        tcp-request connection reject if abuse kill
  \end{verbatim}

\subsubsection[src\_kbytes\_in]{src\_kbytes\_in <integer>}
\subsubsection*{src\_kbytes\_in(<table>) <integer>}
\index{src\_kbytes\_in}
  Returns the amount of data received from the connection's source IPv4 address
  in the current proxy's stick-table or in the designated stick-table, measured
  in kilobytes over the period configured in the table. If the address is not
  found, zero is returned. The test is currently performed on 32-bit integers,
  which limits values to 4 terabytes. See also sc1/sc2\_kbytes\_in.

\subsubsection[src\_kbytes\_out]{src\_kbytes\_out src\_kbytes\_out <integer>}
\subsubsection*{src\_kbytes\_out(<table>) <integer>}
\index{src\_kbytes\_out}
  Returns the amount of data sent to the connection's source IPv4 address in
  the current proxy's stick-table or in the designated stick-table, measured
  in kilobytes over the period configured in the table. If the address is not
  found, zero is returned. The test is currently performed on 32-bit integers,
  which limits values to 4 terabytes. See also sc1/sc2\_kbytes\_out.

\subsubsection[src\_port]{src\_port <integer>}
\index{src\_port}
  Applies to the client's TCP source port. This has a very limited usage.

\subsubsection[src\_sess\_cnt]{src\_sess\_cnt <integer>}
\subsubsection*{src\_sess\_cnt(<table>) <integer>}
\index{src\_sess\_cnt}
  Returns the cumulated number of connections initiated from the current
  connection's source IPv4 address in the current proxy's stick-table or in the
  designated stick-table, that were transformed into sessions, which means that
  they were accepted by "tcp-request" rules. If the address is not found, zero
  is returned. See also sc1/sc2\_sess\_cnt.

\subsubsection[src\_sess\_rate]{src\_sess\_rate <integer>}
\subsubsection*{src\_sess\_rate(<table>) <integer>}
\index{src\_sess\_rate}
  Returns the average session rate from the connection's source IPv4 address in
  the current proxy's stick-table or in the designated stick-table, measured in
  amount of sessions over the period configured in the table. A session is a
  connection that got past the early "tcp-request" rules. If the address is not
  found, zero is returned. See also sc1/sc2\_sess\_rate.

\subsubsection[src\_updt\_conn\_cnt]{src\_updt\_conn\_cnt <integer>}
\subsubsection*{src\_updt\_conn\_cnt(<table>) <integer>}
\index{src\_updt\_conn\_cnt}
  Creates or updates the entry associated to the source IPv4 address in the
  current proxy's stick-table or in the designated stick-table. This table
  must be configured to store the "conn\_cnt" data type, otherwise the match
  will be ignored. The current count is incremented by one, and the expiration
  timer refreshed. The updated count is returned, so this match can't return
  zero. This is used to reject service abusers based on their source address.
  Note: it is recommended to use the more complete "track-counters" instead.

  Example:
  \begin{verbatim}
        # This frontend limits incoming SSH connections to 3 per 10 second for
        # each source address, and rejects excess connections until a 10 second
        # silence is observed. At most 20 addresses are tracked.
        listen ssh
            bind :22
            mode tcp
            maxconn 100
            stick-table type ip size 20 expire 10s store conn_cnt
            tcp-request content reject if { src_update_count gt 3 }
            server local 127.0.0.1:22
  \end{verbatim}

\subsubsection[srv\_conn]{srv\_conn(<backend>/<server>) <integer>}
\index{srv\_conn}
  Applies to the number of currently established connections on the server,
  possibly including the connection being evaluated.
  It can be used to use a specific farm when one server is full.
  See also the "fe\_conn", "be\_conn" and "queue" criteria.

\subsubsection[srv\_id]{srv\_id <integer>}
  Applies to the server's id. Can be used in frontends or backends.

\subsubsection[srv\_is\_up]{srv\_is\_up(<server>)}
\subsubsection*{srv\_is\_up(<backend>/<server>)}
  Returns true when the designated server is UP, and false when it is either
  DOWN or in maintenance mode. If <backend> is omitted, then the server is
  looked up in the current backend. The function takes no arguments since it
  is used as a boolean. It is mainly used to take action based on an external
  status reported via a health check (eg: a geographical site's availability).
  Another possible use which is more of a hack consists in using dummy servers
  as boolean variables that can be enabled or disabled from the CLI, so that
  rules depending on those ACLs can be tweaked in realtime.

\subsubsection[table\_avl]{table\_avl <integer>}
\subsubsection*{table\_avl(<table>) <integer>}
  Returns the total number of available entries in the current proxy's
  stick-table or in the designated stick-table. See also table\_cnt.

\subsubsection[table\_cnt]{table\_cnt <integer>}
\subsubsection*{table\_cnt(<table>) <integer>}
  Returns the total number of entries currently in use in the current proxy's
  stick-table or in the designated stick-table. See also src\_conn\_cnt and
  table\_avl for other entry counting methods.

\subsection{Matching contents at Layer 4 (also called Layer 6)}

A second set of criteria depends on data found in buffers, but which can change
during analysis. This requires that some data has been buffered, for instance
through TCP request content inspection. Please see the "tcp-request content"
keyword for more detailed information on the subject.

\subsubsection[rep\_ssl\_hello\_type]{rep\_ssl\_hello\_type <integer>}
\index{rep\_ssl\_hello\_type}
  Returns true when data in the response buffer looks like a complete SSL (v3
  or superior) hello message and handshake type is equal to <integer>.
  This test was designed to be used with TCP response content inspection: a
  SSL session ID may be fetched.

\subsubsection[req\_len]{req\_len <integer>}
\index{req\_len}
  Returns true when the length of the data in the request buffer matches the
  specified range. It is important to understand that this test does not
  return false as long as the buffer is changing. This means that a check with
  equality to zero will almost always immediately match at the beginning of the
  session, while a test for more data will wait for that data to come in and
  return false only when haproxy is certain that no more data will come in.
  This test was designed to be used with TCP request content inspection.

\subsubsection[req\_proto\_http]{req\_proto\_http}
\index{req\_proto\_http}
  Returns true when data in the request buffer look like HTTP and correctly
  parses as such. It is the same parser as the common HTTP request parser which
  is used so there should be no surprises. This test can be used for instance
  to direct HTTP traffic to a given port and HTTPS traffic to another one
  using TCP request content inspection rules.

\subsubsection[req\_rdp\_cookie]{req\_rdp\_cookie <string>}
\subsubsection*{req\_rdp\_cookie(<name>) <string>}
\index{req\_rdp\_cookie}
  Returns true when data in the request buffer look like the RDP protocol, and
  a cookie is present and equal to <string>. By default, any cookie name is
  checked, but a specific cookie name can be specified in parenthesis. The
  parser only checks for the first cookie, as illustrated in the RDP protocol
  specification. The cookie name is case insensitive. This ACL can be useful
  with the "MSTS" cookie, as it can contain the user name of the client
  connecting to the server if properly configured on the client. This can be
  used to restrict access to certain servers to certain users.

\subsubsection[req\_rdp\_cookie\_cnt]{req\_rdp\_cookie\_cnt <integer>}
\subsubsection*{req\_rdp\_cookie\_cnt(<name>) <integer>}
\index{req\_rdp\_cookie\_cnt}
  Returns true when the data in the request buffer look like the RDP protocol
  and the number of RDP cookies matches the specified range (typically zero or
  one). Optionally a specific cookie name can be checked. This is a simple way
  of detecting the RDP protocol, as clients generally send the MSTS or MSTSHASH
  cookies.

\subsubsection[req\_ssl\_hello\_type]{req\_ssl\_hello\_type <integer>}
\index{req\_ssl\_hello\_type}
  Returns true when data in the request buffer looks like a complete SSL (v3
  or superior) hello message and handshake type is equal to <integer>.
  This test was designed to be used with TCP request content inspection: an
  SSL session ID may be fetched.

\subsubsection[req\_ssl\_sni]{req\_ssl\_sni <string>}
\index{req\_ssl\_sni}
  Returns true when data in the request buffer looks like a complete SSL (v3
  or superior) client hello message with a Server Name Indication TLS extension
  (SNI) matching <string>. SNI normally contains the name of the host the
  client tries to connect to (for recent browsers). SNI is useful for allowing
  or denying access to certain hosts when SSL/TLS is used by the client. This
  test was designed to be used with TCP request content inspection. If content
  switching is needed, it is recommended to first wait for a complete client
  hello (type 1), like in the example below.

  Examples:
  \begin{verbatim}
     # Wait for a client hello for at most 5 seconds
     tcp-request inspect-delay 5s
     tcp-request content accept if { req_ssl_hello_type 1 }
     use_backend bk_allow if { req_ssl_sni -f allowed_sites }
     default_backend bk_sorry_page  
  \end{verbatim}

\subsubsection[req\_ssl\_ver]{req\_ssl\_ver <decimal>}
\index{req\_ssl\_ver}
  Returns true when data in the request buffer look like SSL, with a protocol
  version matching the specified range. Both SSLv2 hello messages and SSLv3
  messages are supported. The test tries to be strict enough to avoid being
  easily fooled. In particular, it waits for as many bytes as announced in the
  message header if this header looks valid (bound to the buffer size). Note
  that TLSv1 is announced as SSL version 3.1. This test was designed to be used
  with TCP request content inspection.

\subsubsection[wait\_end]{wait\_end}
  Waits for the end of the analysis period to return true. This may be used in
  conjunction with content analysis to avoid returning a wrong verdict early.
  It may also be used to delay some actions, such as a delayed reject for some
  special addresses. Since it either stops the rules evaluation or immediately
  returns true, it is recommended to use this acl as the last one in a rule.
  Please note that the default ACL "WAIT\_END" is always usable without prior
  declaration. This test was designed to be used with TCP request content
  inspection.

  Examples:
  \begin{verbatim}
     # delay every incoming request by 2 seconds
     tcp-request inspect-delay 2s
     tcp-request content accept if WAIT_END

     # don't immediately tell bad guys they are rejected
     tcp-request inspect-delay 10s
     acl goodguys src 10.0.0.0/24
     acl badguys  src 10.0.1.0/24
     tcp-request content accept if goodguys
     tcp-request content reject if badguys WAIT_END
     tcp-request content reject
  \end{verbatim}

\subsection{Matching at Layer 7}

A third set of criteria applies to information which can be found at the
application layer (layer 7). Those require that a full HTTP request has been
read, and are only evaluated then. They may require slightly more CPU resources
than the layer 4 ones, but not much since the request and response are indexed.

\subsubsection[cook]{cook(<name>) <string>}
\index{cook}
  All "cook*" matching criteria inspect all "Cookie" headers to find a cookie
  with the name between parenthesis. If multiple occurrences of the cookie are
  found in the request, they will all be evaluated. Spaces around the name and
  the value are ignored as requested by the Cookie specification (RFC6265). The
  cookie name is case-sensitive. Use the scook() variant for response cookies
  sent by the server.

  The "cook" criteria returns true if any of the request cookies <name> match
  any of the strings. This can be used to check exact for values. For instance,
  checking that the "profile" cookie is set to either "silver" or "gold" :
  \begin{verbatim}
       cook(profile) silver gold
  \end{verbatim}

\subsubsection[cook\_beg]{cook\_beg(<name>) <string>}
\index{cook\_beg}
  Returns true if any of the request cookies <name> begins with one of the
  strings. See "cook" for more information on cookie matching. Use the
  scook\_beg() variant for response cookies sent by the server.

\subsubsection[cook\_cnt]{cook\_cnt(<name>) <integer>}
\index{cook\_cnt}
  Returns true when the number of occurrences of the specified cookie matches
  the values or ranges specified. This is used to detect presence, absence or
  abuse of a specific cookie. See "cook" for more information on header
  matching. Use the scook\_cnt() variant for response cookies sent by the
  server.

\subsubsection[cook\_dir]{cook\_dir(<name>) <string>}
\index{cook\_dir}
  Returns true if any of the request cookies <name> contains one of the strings
  either isolated or delimited by slashes. This is used to perform filename or
  directory name matching, though it generally is of limited use with cookies.
  See "cook" for more information on cookie matching. Use the scook\_dir()
  variant for response cookies sent by the server.

\subsubsection[cook\_dom]{cook\_dom(<name>) <string>}
\index{cook\_dom}
  Returns true if any of the request cookies <name> contains one of the strings
  either isolated or delimited by dots. This is used to perform domain name
  matching. See "cook" for more information on cookie matching. Use the
  scook\_dom() variant for response cookies sent by the server.

\subsubsection[cook\_end]{cook\_end(<name>) <string>}
\index{cook\_end}
  Returns true if any of the request cookies <name> ends with one of the
  strings. See "cook" for more information on cookie matching. Use the
  scook\_end() variant for response cookies sent by the server.

\subsubsection[cook\_len]{cook\_len(<name>) <integer>}
\index{cook\_len}
  Returns true if any of the request cookies <name> has a length which matches
  the values or ranges specified. This may be used to detect empty or too large
  cookie values. Note that an absent cookie does not match a zero-length test.
  See "cook" for more information on cookie matching. Use the scook\_len()
  variant for response cookies sent by the server.

\subsubsection[cook\_reg]{cook\_reg(<name>) <regex>}
\index{cook\_reg}
  Returns true if any of the request cookies <name> matches any of the regular
  expressions. It can be used at any time, but it is important to remember that
  regex matching is slower than other methods. See also other "cook\_" criteria,
  as well as "cook" for more information on cookie matching. Use the
  scook\_reg() variant for response cookies sent by the server.

\subsubsection[cook\_sub]{cook\_sub(<name>) <string>}
\index{cook\_sub}
  Returns true if any of the request cookies <name> contains at least one of
  the strings. See "cook" for more information on cookie matching. Use the
  scook\_sub() variant for response cookies sent by the server.

\subsubsection[cook\_val]{cook\_val(<name>) <integer>}
\index{cook\_val}
  Returns true if any of the request cookies <name> starts with a number which
  matches the values or ranges specified. This may be used to select a server
  based on application-specific cookies. Note that an absent cookie does not
  match any value. See "cook" for more information on cookie matching. Use the
  scook\_val() variant for response cookies sent by the server.

\subsubsection[hdr]{hdr <string>}
\subsubsection*{hdr(<header>[,<occ>]) <string>}
\index{hdr}
  \emph{Note:} all the "hdr*" matching criteria either apply to all headers, or to a
  particular header whose name is passed between parenthesis and without any
  space. The header name is not case-sensitive. The header matching complies
  with RFC2616, and treats as separate headers all values delimited by commas.
  If an occurrence number is specified as the optional second argument, only
  this occurrence will be considered. Positive values indicate a position from
  the first occurrence, 1 being the first one. Negative values indicate
  positions relative to the last one, -1 being the last one. Use the shdr()
  variant for response headers sent by the server.

  The "hdr" criteria returns true if any of the headers matching the criteria
  match any of the strings. This can be used to check for exact values. For
  instance, checking that "connection: close" is set:
  \begin{verbatim}
    hdr(Connection) -i close
  \end{verbatim}
     
\subsubsection[hdr\_beg]{hdr\_beg <string>}
\subsubsection{hdr\_beg(<header>[,<occ>]) <string>}
\index{hdr\_beg}
  Returns true when one of the headers begins with one of the strings. See
  "hdr" for more information on header matching. Use the shdr\_beg() variant for
  response headers sent by the server.

\subsubsection[hdr\_cnt]{hdr\_cnt <integer>}
\subsubsection*{hdr\_cnt(<header>) <integer>}
\index{hdr\_cnt}
  Returns true when the number of occurrence of the specified header matches
  the values or ranges specified. It is important to remember that one header
  line may count as several headers if it has several values. This is used to
  detect presence, absence or abuse of a specific header, as well as to block
  request smuggling attacks by rejecting requests which contain more than one
  of certain headers. See "hdr" for more information on header matching. Use
  the shdr\_cnt() variant for response headers sent by the server.

\subsubsection[hdr\_dir]{hdr\_dir <string>}
\subsubsection*{hdr\_dir(<header>[,<occ>]) <string>}
\index{hdr\_dir}
  Returns true when one of the headers contains one of the strings either
  isolated or delimited by slashes. This is used to perform filename or
  directory name matching, and may be used with Referer. See "hdr" for more
  information on header matching. Use the shdr\_dir() variant for response
  headers sent by the server.

\subsubsection[hdr\_dom]{hdr\_dom <string>}
\subsubsection*{hdr\_dom(<header>[,<occ>]) <string>}
\index{hdr\_dom}
  Returns true when one of the headers contains one of the strings either
  isolated or delimited by dots. This is used to perform domain name matching,
  and may be used with the Host header. See "hdr" for more information on
  header matching. Use the shdr\_dom() variant for response headers sent by the
  server.

\subsubsection[hdr\_end]{hdr\_end <string>}
\subsubsection*{hdr\_end(<header>[,<occ>]) <string>}
\index{hdr\_end}
  Returns true when one of the headers ends with one of the strings. See "hdr"
  for more information on header matching. Use the shdr\_end() variant for
  response headers sent by the server.

\subsubsection[hdr\_ip]{hdr\_ip <address>}
\subsubsection*{hdr\_ip(<header>[,<occ>]) <address>}
\index{hdr\_ip}
  Returns true when one of the headers' values contains an IPv4 or IPv6 address
  matching <address>. This is mainly used with headers such as X-Forwarded-For
  or X-Client-IP. See "hdr" for more information on header matching. Use the
  shdr\_ip() variant for response headers sent by the server.

\subsubsection[hdr\_len]{hdr\_len <integer>}
\subsubsection*{hdr\_len(<header>[,<occ>]) <integer>}
\index{hdr\_len}
  Returns true when at least one of the headers has a length which matches the
  values or ranges specified. This may be used to detect empty or too large
  headers. See "hdr" for more information on header matching. Use the
  shdr\_len() variant for response headers sent by the server.

\subsubsection[hdr\_reg]{hdr\_reg <regex>}
\subsubsection*{hdr\_reg(<header>[,<occ>]) <regex>}
\index{hdr\_reg}
  Returns true it one of the headers matches one of the regular expressions. It
  can be used at any time, but it is important to remember that regex matching
  is slower than other methods. See also other "hdr\_" criteria, as well as
  "hdr" for more information on header matching. Use the shdr\_reg() variant for
  response headers sent by the server.

\subsubsection[hdr\_sub]{hdr\_sub <string>}
\subsubsection*{hdr\_sub(<header>[,<occ>]) <string>}
\index{hdr\_sub}
  Returns true when one of the headers contains one of the strings. See "hdr"
  for more information on header matching. Use the shdr\_sub() variant for
  response headers sent by the server.

\subsubsection[hdr\_val]{hdr\_val <integer>}
\subsubsection{hdr\_val(<header>[,<occ>]) <integer>}
\index{hdr\_val}
  Returns true when one of the headers starts with a number which matches the
  values or ranges specified. This may be used to limit content-length to
  acceptable values for example. See "hdr" for more information on header
  matching. Use the shdr\_val() variant for response headers sent by the server.

\subsubsection[http\_auth]{http\_auth(<userlist>)}
\subsubsection[http\_auth\_group]{http\_auth\_group(<userlist>) <group> [<group>]*}
\index{http\_auth}
\index{http\_auth\_group}
  Returns true when authentication data received from the client matches
  username \& password stored on the userlist. It is also possible to
  use http\_auth\_group to check if the user is assigned to at least one
  of specified groups.

  Currently only http basic auth is supported.

\subsubsection[http\_first\_req]{http\_first\_req}
\index{http\_first\_req}
  Returns true when the request being processed is the first one of the
  connection. This can be used to add or remove headers that may be missing
  from some requests when a request is not the first one, or even to perform
  some specific ACL checks only on the first request.

\subsubsection[method]{method <string>}
\index{method}
  Applies to the method in the HTTP request, eg: "GET". Some predefined ACL
  already check for most common methods.

\subsubsection[path]{path <string>}
\index{path}
  Returns true when the path part of the request, which starts at the first
  slash and ends before the question mark, equals one of the strings. It may be
  used to match known files, such as \verb|/favicon.ico|.

\subsubsection[path\_beg]{path\_beg <string>}
\index{path\_beg}
  Returns true when the path begins with one of the strings. This can be used
  to send certain directory names to alternative backends.

\subsubsection[path\_dir]{path\_dir <string>}
\index{path\_dir}
  Returns true when one of the strings is found isolated or delimited with
  slashes in the path. This is used to perform filename or directory name
  matching without the risk of wrong match due to colliding prefixes. See also
  "url\_dir" and "path\_sub".

\subsubsection[path\_dom]{path\_dom <string>}
\index{path\_dom}
  Returns true when one of the strings is found isolated or delimited with dots
  in the path. This may be used to perform domain name matching in proxy
  requests. See also "path\_sub" and "url\_dom".

\subsubsection[path\_end]{path\_end <string>}
\index{path\_end}
  Returns true when the path ends with one of the strings. This may be used to
  control file name extension.

\subsubsection[path\_len]{path\_len <integer>}
\index{path\_len}
  Returns true when the path length matches the values or ranges specified.
  This may be used to detect abusive requests for instance.

\subsubsection[path\_reg]{path\_reg <regex>}
\index{path\_reg}
  Returns true when the path matches one of the regular expressions. It can be
  used any time, but it is important to remember that regex matching is slower
  than other methods. See also "url\_reg" and all "path\_" criteria.

\subsubsection[path\_sub]{path\_sub <string>}
\index{path\_sub}
  Returns true when the path contains one of the strings. It can be used to
  detect particular patterns in paths, such as "\verb|../|" for example. See also
  "path\_dir".

\subsubsection[payload]{payload(<offset>,<length>) <string>}
\index{payload}
  Returns true if the block of <length> bytes, starting at byte <offset> in the
  request or response buffer (depending on the rule) exactly matches one of the
  strings.

\subsubsection[payload\_lv]{payload\_lv(<offset1>,<length>[,<offset2>])}
\index{payload\_lv}
  Returns true if the block whose size is specified at <offset1> for <length>
  bytes, and which starts at <offset2> if specified or just after the length in
  the request or response buffer (depending on the rule) exactly matches one of
  the strings. The <offset2> parameter also supports relative offsets if
  prepended with a '+' or '-' sign.

\subsubsection[req\_ver]{req\_ver <string>}
  Applies to the version string in the HTTP request, eg: "1.0". Some predefined
  ACL already check for versions 1.0 and 1.1.

\subsubsection[status]{status <integer>}
\index{status}
  Applies to the HTTP status code in the HTTP response, eg: "302". It can be
  used to act on responses depending on status ranges, for instance, remove
  any Location header if the response is not a 3xx.

\subsubsection[url]{url <string>}
\index{url}
  Applies to the whole URL passed in the request. The only real use is to match
  "*", for which there already is a predefined ACL.

\subsubsection[url\_beg]{url\_beg <string>}
\index{url\_beg}
  Returns true when the URL begins with one of the strings. This can be used to
  check whether a URL begins with a slash or with a protocol scheme.

\subsubsection[url\_dir]{url\_dir <string>}
\index{url\_dir}
  Returns true when one of the strings is found isolated or delimited with
  slashes in the URL. This is used to perform filename or directory name
  matching without the risk of wrong match due to colliding prefixes. See also
  "path\_dir" and "url\_sub".

\subsubsection[url\_dom]{url\_dom <string>}
\index{url\_dom}
  Returns true when one of the strings is found isolated or delimited with dots
  in the URL. This is used to perform domain name matching without the risk of
  wrong match due to colliding prefixes. See also "url\_sub".

\subsubsection[url\_end]{url\_end <string>}
\index{url\_end}
  Returns true when the URL ends with one of the strings. It has very limited
  use. "path\_end" should be used instead for filename matching.

\subsubsection[url\_ip]{url\_ip <address>}
\index{url\_ip}
  Applies to the IPv4 or IPv6 address specified in the absolute URI in an HTTP
  request. It can be used to prevent access to certain resources such as local
  network. It is useful with option "http\_proxy".

\subsubsection[url\_len]{url\_len <integer>}
\index{url\_len}
  Returns true when the url length matches the values or ranges specified. This
  may be used to detect abusive requests for instance.

\subsubsection[url\_port]{url\_port <integer>}
\index{url\_port}
  Applies to the port specified in the absolute URI in an HTTP request. It can
  be used to prevent access to certain resources. It is useful with option
  "http\_proxy". Note that if the port is not specified in the request, port 80
  is assumed.

\subsubsection[url\_reg]{url\_reg <regex>}
\index{url\_reg}
  Returns true when the URL matches one of the regular expressions. It can be
  used any time, but it is important to remember that regex matching is slower
  than other methods. See also "path\_reg" and all "url\_" criteria.

\subsubsection[url\_sub]{url\_sub <string>}
\index{url\_sub}
  Returns true when the URL contains one of the strings. It can be used to
  detect particular patterns in query strings for example. See also "path\_sub".

\subsubsection[urlp]{urlp(<name>) <string>}
\index{urlp}
  \emph{Note:} all "urlp*" matching criteria apply to the first occurrence of the
  parameter <name> in the query string. The parameter name is case-sensitive.

  The "urlp" matching criteria returns true if the designated URL parameter
  matches any of the strings. This can be used to check for exact values.

\subsubsection[urlp\_beg]{urlp\_beg(<name>) <string>}
\index{urlp\_beg}
  Returns true when the URL parameter "<name>" begins with one of the strings.
  This can be used to check whether a URL begins with a slash or with a
  protocol scheme.

\subsubsection[urlp\_dir]{urlp\_dir(<name>) <string>}
\index{urlp\_dir}
  Returns true when the URL parameter "<name>" contains one of the strings
  either isolated or delimited with slashes. This is used to perform filename
  or directory name matching in a specific URL parameter without the risk of
  wrong match due to colliding prefixes. See also "path\_dir" and "urlp\_sub".

\subsubsection[urlp\_dom]{urlp\_dom(<name>) <string>}
\index{urlp\_dom}
  Returns true when one of the strings is found isolated or delimited with dots
  in the URL parameter "<name>". This is used to perform domain name matching
  in a specific URL parameter without the risk of wrong match due to colliding
  prefixes. See also "urlp\_sub".

\subsubsection[urlp\_end]{urlp\_end(<name>) <string>}
\index{urlp\_end}
  Returns true when the URL parameter "<name>" ends with one of the strings.

\subsubsection[urlp\_ip]{urlp\_ip(<name>) <address>}
\index{urlp\_ip}
  Returns true when the URL parameter "<name>" contains an IPv4 or IPv6 address
  which matches one of the specified addresses.

\subsubsection[urlp\_len]{urlp\_len(<name>) <integer>}
\index{urlp\_len}
  Returns true when the URL parameter "<name>" has a length matching the values
  or ranges specified. This is used to detect abusive requests for instance.

\subsubsection[urlp\_reg]{urlp\_reg(<name>) <regex>}
\index{urlp\_reg}
  Returns true when the URL parameter "<name>" matches one of the regular
  expressions. It can be used any time, but it is important to remember that
  regex matching is slower than other methods. See also "path\_reg" and all
  "urlp\_" criteria.

\subsubsection[urlp\_sub]{urlp\_sub(<name>) <string>}
\index{urlp\_sub}
  Returns true when the URL parameter "<name>" contains one of the strings. It
  can be used to detect particular patterns in query strings for example. See
  also "path\_sub" and other "urlp\_" criteria.

\section{Pre-defined ACLs}

Some predefined ACLs are hard-coded so that they do not have to be declared in
every frontend which needs them. They all have their names in upper case in
order to avoid confusion. Their equivalence is provided below.

\begin{tabular}{lll}
\head{ACL name} & \head{Equivalent to} & \head{Usage} \\
\hline
FALSE          & always\_false                & never match \\
HTTP           & req\_proto\_http              & match if protocol is valid HTTP \\
HTTP\_1.0       & req\_ver 1.0                 & match HTTP version 1.0 \\
HTTP\_1.1       & req\_ver 1.1                 & match HTTP version 1.1 \\
HTTP\_CONTENT   & hdr\_val(content-length) gt 0& match an existing content-length \\
HTTP\_URL\_ABS   & url\_reg \verb|^[^/:]*://|   & match absolute URL with scheme \\
HTTP\_URL\_SLASH & url\_beg /                   & match URL beginning with "/" \\
HTTP\_URL\_STAR  & url     *                   & match URL equal to "*" \\
LOCALHOST      & src 127.0.0.1/8             & match connection from local host \\
METH\_CONNECT  & method  CONNECT             & match HTTP CONNECT method \\
METH\_GET      & method  GET HEAD            & match HTTP GET or HEAD method \\
METH\_HEAD     & method  HEAD                & match HTTP HEAD method \\
METH\_OPTIONS  & method  OPTIONS             & match HTTP OPTIONS method \\
METH\_POST     & method  POST                & match HTTP POST method \\
METH\_TRACE    & method  TRACE               & match HTTP TRACE method \\
RDP\_COOKIE    & req\_rdp\_cookie\_cnt gt 0     & match presence of an RDP cookie \\
REQ\_CONTENT   & req\_len gt 0                & match data in the request buffer \\
TRUE           & always\_true                 & always match \\
WAIT\_END      & wait\_end                    & wait for end of content analysis \\
\hline
\end{tabular}

\section{Using ACLs to form conditions}

\index{ACL Conditions}
Some actions are only performed upon a valid condition. A condition is a
combination of ACLs with operators. 3 operators are supported :

\begin{itemize}
\item[-] AND (implicit)
\item[-] OR  (explicit with the "or" keyword or the "||" operator)
\item[-] Negation with the exclamation mark ("!")
\end{itemize}

A condition is formed as a disjunctive form:

\begin{verbatim}
   [!]acl1 [!]acl2 ... [!]acln  { or [!]acl1 [!]acl2 ... [!]acln } ...
\end{verbatim}

Such conditions are generally used after an "if" or "unless" statement,
indicating when the condition will trigger the action.

For instance, to block HTTP requests to the "*" URL with methods other than
"OPTIONS", as well as POST requests without content-length, and GET or HEAD
requests with a content-length greater than 0, and finally every request which
is not either GET/HEAD/POST/OPTIONS!

\begin{verbatim}
   acl missing_cl hdr_cnt(Content-length) eq 0
   block if HTTP_URL_STAR !METH_OPTIONS || METH_POST missing_cl
   block if METH_GET HTTP_CONTENT
   block unless METH_GET or METH_POST or METH_OPTIONS
\end{verbatim}

To select a different backend for requests to static contents on the "www" site
and to every request on the "img", "video", "download" and "ftp" hosts :

\begin{verbatim}
   acl url_static  path_beg         /static /images /img /css
   acl url_static  path_end         .gif .png .jpg .css .js
   acl host_www    hdr_beg(host) -i www
   acl host_static hdr_beg(host) -i img. video. download. ftp.

   # now use backend "static" for all static-only hosts, and for static urls
   # of host "www". Use backend "www" for the rest.
   use_backend static if host_static or host_www url_static
   use_backend www    if host_www
\end{verbatim}

It is also possible to form rules using "anonymous ACLs". Those are unnamed ACL
expressions that are built on the fly without needing to be declared. They must
be enclosed between braces, with a space before and after each brace (because
the braces must be seen as independant words). Example:

   The following rule:

\begin{verbatim}
       acl missing_cl hdr_cnt(Content-length) eq 0
       block if METH_POST missing_cl
\end{verbatim}

   Can also be written that way:

\begin{verbatim}
       block if METH_POST { hdr_cnt(Content-length) eq 0 }
\end{verbatim}

It is generally not recommended to use this construct because it's a lot easier
to leave errors in the configuration when written that way. However, for very
simple rules matching only one source IP address for instance, it can make more
sense to use them than to declare ACLs with random names. Another example of
good use is the following:

   With named ACLs:
   
   \begin{verbatim}
        acl site_dead nbsrv(dynamic) lt 2
        acl site_dead nbsrv(static)  lt 2
        monitor fail  if site_dead
   \end{verbatim}

   With anonymous ACLs:

   \begin{verbatim}
        monitor fail if { nbsrv(dynamic) lt 2 } || { nbsrv(static) lt 2 }
   \end{verbatim}

See section 4.2 for detailed help on the "block" and "use\_backend" keywords.

\section{Pattern extraction}

The stickiness features relies on pattern extraction in the request and
response. Sometimes the data needs to be converted first before being stored,
for instance converted from ASCII to IP or upper case to lower case.

All these operations of data extraction and conversion are defined as
"pattern extraction rules". A pattern rule always has the same format. It
begins with a single pattern fetch word, potentially followed by a list of
arguments within parenthesis then an optional list of transformations. As
much as possible, the pattern fetch functions use the same name as their
equivalent used in ACLs.

The list of currently supported pattern fetch functions is the following:

\begin{description}
\item[src]
               This is the source IPv4 address of the client of the session.
               It is of type IPv4 and works on both IPv4 and IPv6 tables.
               On IPv6 tables, IPv4 address is mapped to its IPv6 equivalent,
               according to RFC 4291.

\item[dst]
               This is the destination IPv4 address of the session on the
               client side, which is the address the client connected to.
               It can be useful when running in transparent mode. It is of
               type IPv4 and works on both IPv4 and IPv6 tables.
               On IPv6 tables, IPv4 address is mapped to its IPv6 equivalent,
               according to RFC 4291.

\item[dst\_port]
               This is the destination TCP port of the session on the client
               side, which is the port the client connected to. This might be
               used when running in transparent mode or when assigning dynamic
               ports to some clients for a whole application session. It is of
               type integer and only works with such tables.

\item[{hdr(<name>[,<occ>])}]
               This extracts the last occurrence of header <name> in an HTTP
               request. Optionally, a specific occurrence might be specified as
               a position number. Positive values indicate a position from the
               first occurrence, with 1 being the first one. Negative values
               indicate positions relative to the last one, with -1 being the
               last one. A typical use is with the X-Forwarded-For header once
               converted to IP, associated with an IP stick-table.

\item[payload(<offset>,<length>)]
               This extracts a binary block of <length> bytes, and starting
               at bytes <offset> in the buffer of request or response (request
               on "stick on" or "stick match" or response in on "stick store
               response").

\item[{payload\_lv(<offset1>,<length>[,<offset2>])}]
               This extracts a binary block. In a first step the size of the
               block is read from response or request buffer at <offset>
               bytes and considered coded on <length> bytes. In a second step
               data of the block are read from buffer at <offset2> bytes
               (by default <lengthoffset> + <lengthsize>).
               If <offset2> is prefixed by '+' or '-', it is relative to
               <lengthoffset> + <lengthsize> else it is absolute.
               Ex: see SSL session id  example in "stick table" chapter.

\item[src\_port] 
               This is the source TCP port of the session on the client side,
               which is the port the client connected from. It is very unlikely
               that this function will be useful but it's available at no cost.
               It is of type integer and only works with such tables.

\item[url\_param(<name>)]
               This extracts the first occurrence of the parameter <name> in
               the query string of the request and uses the corresponding value
               to match. A typical use is to get sticky session through url
               (e.g. \verb|http://example.com/foo?JESSIONID=some_id| with
               url\_param (JSESSIONID)), for cases where cookies cannot be used.

\item[rdp\_cookie(<name>)]
               This extracts the value of the rdp cookie <name> as a string
               and uses this value to match. This enables implementation of
               persistence based on the mstshash cookie. This is typically
               done if there is no msts cookie present.

               This differs from "balance rdp-cookie" in that any balancing
               algorithm may be used and thus the distribution of clients
               to backend servers is not linked to a hash of the RDP
               cookie. It is envisaged that using a balancing algorithm
               such as "balance roundrobin" or "balance leastconnect" will
               lead to a more even distribution of clients to backend
               servers than the hash used by "balance rdp-cookie".

               Example:
               \begin{verbatim}
                listen tse-farm
                    bind 0.0.0.0:3389
                    # wait up to 5s for an RDP cookie in the request
                    tcp-request inspect-delay 5s
                    tcp-request content accept if RDP_COOKIE
                    # apply RDP cookie persistence
                    persist rdp-cookie
                    # Persist based on the mstshash cookie
                    # This is only useful makes sense if
                    # balance rdp-cookie is not used
                    stick-table type string size 204800
                    stick on rdp_cookie(mstshash)
                    server srv1 1.1.1.1:3389
                    server srv1 1.1.1.2:3389
               \end{verbatim}

               See also: \kwl{balance rdp-cookie}, \kwl{persist rdp-cookie},
               "tcp-request" and the "req\_rdp\_cookie" ACL.

\item[cookie(<name>)]
               This extracts the last occurrence of the cookie name <name> on a
               "Cookie" header line from the request, or a "Set-Cookie" header
               from the response, and uses the corresponding value to match. A
               typical use is to get multiple clients sharing a same profile
               use the same server. This can be similar to what "appsession"
               does with the "request-learn" statement, but with support for
               multi-peer synchronization and state keeping across restarts.

               See also: \kwl{appsession}

\item[set-cookie(<name>)]
               This fetch function is deprecated and has been superseded by the
               "cookie" fetch which is capable of handling both requests and
               responses. This keyword will disappear soon.

               This extracts the last occurrence of the cookie name <name> on a
               "Set-Cookie" header line from the response and uses the
               corresponding value to match. This can be comparable to what
               "appsession" does with default options, but with support for
                multi-peer synchronization and state keeping across restarts.
                
                See also: \kwl{appsession}
\end{description}

The currently available list of transformations include:

\begin{description}
\item[lower]
               Convert a string pattern to lower case. This can only be placed
               after a string pattern fetch function or after a conversion
               function returning a string type. The result is of type string.

\item[upper]
               Convert a string pattern to upper case. This can only be placed
               after a string pattern fetch function or after a conversion
               function returning a string type. The result is of type string.

\item[ipmask(<mask>)]
               Apply a mask to an IPv4 address, and use the result for lookups
               and storage. This can be used to make all hosts within a
               certain mask to share the same table entries and as such use
               the same server. The mask can be passed in dotted form (eg:
               255.255.255.0) or in CIDR form (eg: 24).
\end{description}